var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"All APIs from Sym4state.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"For the theoretical exploration of the magnetic properties of magnets, the bilinear Heisenberg model proves to be a useful framework for representing magnetic interactions, which can be described by","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"mathcalH = sum_i  j S_i cdot mathcalJ_i j cdot S_j + sum_i S_i cdot mathcalA cdot S_i - m sum_i S_i cdot vecB","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where the symbol mathcalJ_ij denotes the exchange interaction matrix between two spins, S_i and S_j, the matrix mathcalA represents the single-ion anisotropy. To determine the magnetic interaction matrix elements, researchers often employ the four-state method [1] [2] [3]. This method involves calculating the energies of four distinct magnetic configurations, allowing the extraction of individual components for the exchange matrix.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Extending this method to each element of the exchange matrix requires calculating a total of 36 energies to obtain the complete matrix. It should be noted that some energies are degenerate due to the symmetry of the material. Nonetheless, performing a manual symmetric analysis to streamline the number of energy calculations remains a challenging endeavor, as there exists a potential risk of omitting or misinterpreting certain symmetric operations.","category":"page"},{"location":"manual/#Pre-process","page":"Manual","title":"Pre-process","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"One can use our program to streamline the simpilifing and calculating process easily. For example, with a POSCAR file of monolayer ceCrI3","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Cr2 I6                                  \n   1.00000000000000     \n     7.1131374882967124    0.0000000000000000    0.0000000000000000\n    -3.5565687441483571    6.1601577654763897    0.0000000000000000\n     0.0000000000000000    0.0000000000000000   18.0635365764484419\n   Cr   I \n     2     6\nDirect\n  0.6666666666666643  0.3333333333333357  0.5000000247180765\n  0.3333333333333357  0.6666666666666643  0.5000000501683317\n  0.6415738047516142  0.9999977877949036  0.4116659127023310\n  0.3584239830432894  0.3584261952483858  0.4116659127023310\n  0.0000022122051035  0.6415760169567106  0.4116659127023310\n  0.3584241488090230  0.9999980859273947  0.5883340783387269\n  0.6415739371183646  0.6415758511909699  0.5883340783387269\n  0.0000019140726053  0.3584260628816354  0.5883340783387269","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"and the proper setted INCAR, POTCAR and KPOINTS for making SCF calculation, one can simply using Sym4state.jl to generate all the input files for calculating the nearest exchange interaction and the single-ion anisotropy interaction as follows:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Sym4state\ncd(\"CrI3\") do   # hide\nSym4state.pre_process(\n    \"./POSCAR\",\n    [24],   # Take Cr element as magnetic\n    5.0     # There exists an interaction between atoms within a distance of 5 Å.\n)\nend # hide","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This function will utilize the supercell_check method to create a supercell for the provided structure. The supercell should be sufficiently large to ensure that no more than one connection exists within a specified cutoff radius between any two atoms. For the given case of a monolayer of ceCrI3 with a cutoff radius of 5 Å, a 2 times 2 times 1 supercell will provide sufficient size. The supercell diagram below labels all the ceCr atoms:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(Image: Top view of monolayer ``\\ce{CrI3}``)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Within the 5 Å cutoff radius, the monolayer of ceCrI3 exhibits two distinct groups of interactions. The first group corresponds to interactions between nearest neighbors, whereas the second group pertains to interactions arising from single-ion anisotropy. It is important to note that all atom pairs within the same group are considered equivalent. This equivalence implies the existence of symmetric operations that can transform one interaction matrix into another, highlighting the underlying symmetry of the system.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As evidenced by the output obtained from the pre_process function, the initial group contains 6 pairs that are equivalent, while the second group consists of 2 equivalent pairs. Despite the potential for simplifying the calculations involving various interaction matrices through the use of symmetric operations, there remains one particular interaction matrix that necessitates the calculation of the fewest number of configurations. In the case of the nearest neighbor interaction, it is essential to compute the energies for a minimum of 9 magnetic configurations. Conversely, when dealing with the single-ion anisotropy interaction, the energies of at least 2 magnetic configurations need to be evaluated.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The function will restore all the relations between different energies and configurations into a file cal.jld2. Moreover, this function will generate numerous directories to store input files corresponding to the various magnetic configurations.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"printfiletree(\"CrI3\")   # hide","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All the path of those directories is stored in the file cal_list, one could use this file to create a Slurm's job array by submitting a shell like:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"#!/bin/sh\n\n#SBATCH -n 144\n#SBATCH --array=1-11%2\n\nmodule load vasp-6.3.2-optcell\n\ntarget_dir=$(sed -n \"${SLURM_ARRAY_TASK_ID}p\" cal_dir_list)\n\ncd ${target_dir}\n\nsrun vasp_ncl","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This shell script aims to create a Slurm job array to compute the energies of all 11 magnetic configurations, while efficiently managing computational resources by allowing a maximum of 2 jobs to run simultaneously.","category":"page"},{"location":"manual/#Post-process","page":"Manual","title":"Post-process","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Once all the calculations have converged, you can utilize the post_process function to extract the energies associated with different configurations. This process ultimately leads to the construction of an interaction matrix.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"cd(\"CrI3\") do   # hide\nglobal pair_mat, coeff_array    # hide\nmv(\"../oszicar.tar.gz\", \"./oszicar.tar.gz\") # hide\nrun(`tar -xvzf oszicar.tar.gz`) # hide\nfor (idx, dir_name) in enumerate(readlines(\"cal_dir_list\")) # hide\n    cp(\"oszicar/OSZICAR_$(idx)\", dir_name * \"OSZICAR\")  # hide\nend # hide\npair_mat, coeff_array = Sym4state.post_process(\"./cal.jld2\")\nend # hide","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can examine the dimensions of pair_mat and coeff_array, which store the indices of the starting and ending points for various atom pairs and their corresponding interaction matrices, respectively.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"size(pair_mat)\nsize(coeff_array)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Hence, we observe that there exist a total of 8 interactions within a cutoff radius of 5 Å. Let us inspect a specific entry in pair_mat that contains the indices representing an atom pair:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"pair_mat[:, 1]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The initial and final numbers correspond to the indices of the starting and ending point atoms, respectively. The second and third numbers indicate the offset of the primitive cell along the x-axis and y-axis.","category":"page"},{"location":"manual/#Monte-Carlo-Simulation","page":"Manual","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"With the former result pair_mat and coeff_array, we could set up a configuration for Monte Carlo simulation to determining the phase transition temperature or magnetic texture like:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Unitful, UnitfulAtomic\nmcconfig = Sym4state.MC.MCConfig{Float32}(\n    lattice_size=[128, 128],\n    magmom_vector=[3.5, 3.5],\n    pair_mat=pair_mat,\n    interact_coeff_array=coeff_array,\n    temperature=collect(150:-2:0),\n    magnetic_field=zeros(3),\n    equilibration_step_num=100_000,\n    measuring_step_num=100_000\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In the aforementioned code snippet, we have configured a simulated annealing simulation, commencing at a temperature of 150 K and progressively reducing it to 0 K in steps of 2 K. The simulation operates on a 128 times 128 supercell of ceCrI3 using the previously computed interaction matrix. To assess the system, we perform a preliminary equilibration phase consisting of 100000 sweeps, followed by a measurement phase comprising 100000 sweeps for acquiring physical quantities. It is worth noting that the magnetic field is absent, rendering the magmom_vector inconsequential.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"With the created mcconfig, one can initiate a Monte Carlo simulation as follows:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(\n    states_over_env,\n    norm_mean_mag_over_env,\n    susceptibility_over_env,\n    specific_heat_over_env\n) = Sym4state.MC.mcmc(\n    mcconfig,\n    backend=Sym4state.MC.CPU()\n    progress_enabled=false,\n    log_enabled=false\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The parameter backend can be configured to employ CUDABackend() provided by CUDA.jl or any other backends supported by KernelAbstractions.jl to enhance performance utilizing the GPU.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The MCConfig can also be stored into a .toml file by:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"cd(\"CrI3\") do   # hide\nSym4state.MC.save_config(\"CrI3.toml\", mcconfig)\nend # hide","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"or it can also be restored by:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"cd(\"CrI3\") do   # hide\nmcconfig = Sym4state.MC.load_config(\"CrI3.toml\")\nend # hide","category":"page"},{"location":"manual/#Functions","page":"Manual","title":"Functions","text":"","category":"section"},{"location":"manual/#Sym4state.ModCore.reduce_interact_mat_for_a_pair","page":"Manual","title":"Sym4state.ModCore.reduce_interact_mat_for_a_pair","text":"This function employs all the given symmetric operations in symopvec to identify the analogous connections among the provided magnetic configurations in magstrucvec. By doing so, it effectively reduces the total count of magnetic configurations required for calculating the interaction matrix between two atoms.\n\nreduce_interact_mat_for_a_pair(mag_struc_vec::Vector{Sym4state.Types.Struc}, sym_op_vec::Vector{Sym4state.Types.SymOp}) -> DataStructures.IntDisjointSets{Int64}\n\n\n\n\n\n\n","category":"function"},{"location":"manual/#Sym4state.ModCore.supercell_check","page":"Manual","title":"Sym4state.ModCore.supercell_check","text":"This function checks whether the size of the supercell is big enough for the given cutoff_radius.\n\nsupercell_check(py_refined_struc, mag_num_vec, mag_atom_count, cutoff_radius) -> Tuple{Sym4state.Types.Struc, Any, Vector{Sym4state.Types.SymOp}, Union{Nothing, DataStructures.DisjointSets{Vector{Int64}}}, Union{Nothing, Dict{Vector{Int64}, Sym4state.Types.SymOp}}}\n\n\n\n\n\n\n","category":"function"},{"location":"manual/#Sym4state.ModCore.pre_process","page":"Manual","title":"Sym4state.ModCore.pre_process","text":"This function takes a file path, a magnetic number vector, a cutoff radius, and some optional parameters. It performs symmetry analysis on the structure in the file and saves the results into a file named \"cal.jld2\". It also prepares the inputs for VASP.\n\npre_process(filepath, mag_num_vec, cutoff_radius)\n\n\n\n\n\n\nThis function takes a file path and some optional parameters. It loads the symmetry information from the file and prepares the inputs for VASP.\n\npre_process(filepath)\n\n\n\n\n\n\n","category":"function"},{"location":"manual/#Sym4state.ModCore.post_process","page":"Manual","title":"Sym4state.ModCore.post_process","text":"This function takes a file path. It loads the symmetry information from the file and calculates a pair matrix and a coefficient array.\n\npost_process(cal_file_path::String) -> Tuple{Matrix{Int64}, Array{Float64, 3}}\n\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"rm(\"CrI3\", recursive=true)\nnothing","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"[1]: Xiang, H. J., et al. \"Predicting the spin-lattice order of frustrated systems from first principles.\" Physical Review B 84.22 (2011): 224429.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"[2]: Šabani, D., C. Bacaksiz, and M. V. Milošević. \"Ab initio methodology for magnetic exchange parameters: Generic four-state energy mapping onto a Heisenberg spin Hamiltonian.\" Physical Review B 102.1 (2020): 014457.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"[3]: Xiang, Hongjun, et al. \"Magnetic properties and energy-mapping analysis.\" Dalton Transactions 42.4 (2013): 823-853.","category":"page"},{"location":"#Sym4state","page":"Home","title":"Sym4state","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A program specifically designed to simplify the computation of magnetic interaction matrix and simulate spin textures under various environmental conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please proceed to acquire and install the appropriate version of Julia (version 1.9 or higher) for your specific platform by visiting this location.","category":"page"},{"location":"","page":"Home","title":"Home","text":"And add the package by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(url=\"https://github.com/A-LOST-WAPITI/Sym4state.jl\")","category":"page"},{"location":"#Brief-overview","page":"Home","title":"Brief overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main functions are pre_process, post_process and Sym4state.MC.mcmc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The pre_process function facilitates the streamlined computation of interacting matrices within a specified cutoff radius. To illustrate its usage, let's consider an example where we aim to evaluate all the interactions within a cutoff radius of 5 Å for a monolayer of ceCrI3. To achieve this, you can effortlessly execute the following code snippet, assuming you have the required files such as POSCAR (containing the structure of ceCrI3), as well as the POTCAR, INCAR, and KPOINTS files utilized in energy determination:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Sym4state\nSym4state.pre_process(\n    \"./POSCAR\",\n    [24],\n    5.0;\n    incar_path=\"./INCAR\",\n    potcar_path=\"./POTCAR\",\n    kpoints_path=\"./KPOINTS\"\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that you should replace \"POSCAR\", \"POTCAR\", \"INCAR\", and \"KPOINTS\" with the actual filenames corresponding to your system's specific input files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Upon invoking the pre_process function, it will automate the creation of magnetic configurations with the minimal number of energies required for interaction determination. These configurations will be saved in separate directories. Once all the DFT calculations have converged, you can employ the post_process function to obtain the interacting matrix. This process can be accomplished using the following Julia code snippet:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pair_mat, coeff_array = Sym4state.post_process(\"./cal.jld2\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The variable pair_mat contains the indices of atom pairs, while coeff_array holds the interacting matrix. With this information, you can establish a Monte Carlo simulation to further analyze the system by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Unitful, UnitfulAtomic, CUDA\n\nmcconfig = Sym4state.MC.MCConfig{Float32}(\n    lattice_size=[128, 128],\n    magmom_vector=[3.5, 3.5],\n    pair_mat=pair_mat,\n    interact_coeff_array=coeff_array,\n    temperature=collect(150:-2:0),\n    magnetic_field=zeros(3),\n    equilibration_step_num=100_000,\n    measuring_step_num=100_000\n)\n(\n    states_over_env,\n    norm_mean_mag_over_env,\n    susceptibility_over_env,\n    specific_heat_over_env\n) = Sym4state.MC.mcmc(\n    mcconfig,\n    backend=CUDABackend()\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the Monte Carlo simulation, one can illustrate the ultimate magnetic configuration simpily by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CairoMakie\nfig = Sym4state.MC.plot(\n    states_over_env[:, :, :, :, end],\n    Float32[1 -1/2; 0 sqrt(3)/2],\n    Float32[1/3 2/3; 2/3 1/3],\n    1:24,\n    1:24\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is important to note that the 2D cell matrix, the fractional coordinates of the magnetic atoms, and the desired plotting range of cells along the x- and y-axes must be supplied as inputs to this function.","category":"page"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This page shows all the functions defined in Sym4state.Utils.","category":"page"},{"location":"utils/#Module","page":"Utilities","title":"Module","text":"","category":"section"},{"location":"utils/#Sym4state.Utils","page":"Utilities","title":"Sym4state.Utils","text":"This module defines useful functions for simplifying the four-state method.\n\nThis module exports:\n\ncheck_unit_cell\ncheck_z_rot\nequal_pair\nget_all_interact_struc_vec\nget_fixed_pair_vec\nget_pair_and_coeff\nget_py_struc\nget_sym_op_vec\nlinear_idx_to_vec\nmagonly\npy_struc_to_struc\nstruc_compare\nto_vasp_inputs\n\n\n\n\n\n","category":"module"},{"location":"utils/#Functions","page":"Utilities","title":"Functions","text":"","category":"section"},{"location":"utils/#Structures-and-configurations","page":"Utilities","title":"Structures and configurations","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This section contains functions working with structures or magnetic configurations.","category":"page"},{"location":"utils/#Sym4state.Utils.mag_config","page":"Utilities","title":"Sym4state.Utils.mag_config","text":"This function yields an array with size of [3, mag_count, 36] that comprises all 36 magnetic configurations utilized in the computation of the interaction matrix for a given number of magnetic atoms mag_count and the initial norm value s_value of MAGMOM. \n\nThe resulting configurations pertain to the interaction between two atoms specified by the target_idx_vec vector.\n\nmag_config(mag_count::Int64, target_idx_vec::Vector{Int64}, s_value::Float64) -> Array{Float64, 3}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.py_struc_to_struc","page":"Utilities","title":"Sym4state.Utils.py_struc_to_struc","text":"This function transforms the Structure object from Pymatgen into a Struc object.\n\nThe distinct identifier uni_num will be supplied to the Struc object. The spin_mat variable represents the spin value assigned to each atom in the structure.\n\npy_struc_to_struc(py_struc) -> Sym4state.Types.Struc\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_all_interact_struc_vec","page":"Utilities","title":"Sym4state.Utils.get_all_interact_struc_vec","text":"By utilizing the mag_config, this function generates all the Struc objects required for calculating the interaction matrix.\n\nIt takes the atomic numbers of magnetic elements stored in mag_num_vec, the index of target atoms denoted by target_idx_vec, and the initial value s_value.\n\nget_all_interact_struc_vec(struc::Sym4state.Types.Struc, mag_num_vec::Vector{Int64}, target_idx_vec::Vector{Int64}, s_value::Float64) -> Vector{Sym4state.Types.Struc}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.struc_compare","page":"Utilities","title":"Sym4state.Utils.struc_compare","text":"This function examines two Struc objects and determines their approximate equivalence within a tolerance of atol.\n\nIt returns a Tuple that includes a boolean value indicating whether they are equal,  as well as the corresponding relationships among the atoms in the respective structures.\n\nstruc_compare(x::Sym4state.Types.Struc, y::Sym4state.Types.Struc) -> Tuple{Bool, Dict{Int64, Int64}}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.magonly","page":"Utilities","title":"Sym4state.Utils.magonly","text":"This function filters out the non-magnetic atoms in the struc structure. The atomic numbers of magnetic elements are provided in the mag_num_vec.\n\nmagonly(struc::Sym4state.Types.Struc, mag_num_vec::Vector{Int64}) -> Sym4state.Types.Struc\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Symmetric-operations","page":"Utilities","title":"Symmetric operations","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This section contains functions working with space group and symmetric operations.","category":"page"},{"location":"utils/#Sym4state.Utils.check_z_rot_mat","page":"Utilities","title":"Sym4state.Utils.check_z_rot_mat","text":"This function examines a matrix and determines whether it represents a rotational matrix around the z-axis.\n\ncheck_z_rot_mat(x::AbstractArray{T, 2}) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.check_z_rot","page":"Utilities","title":"Sym4state.Utils.check_z_rot","text":"This function examines a SymOp and determines whether it contains a rotational matrix around the z-axis.\n\ncheck_z_rot(op::Sym4state.Types.SymOp) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_sym_op_vec","page":"Utilities","title":"Sym4state.Utils.get_sym_op_vec","text":"This function using pymatgen.symmetry.analyzer from Pymatgen to get all the symmetric operations.\n\nget_sym_op_vec(py_sga) -> Vector{Sym4state.Types.SymOp}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Atom-pairs","page":"Utilities","title":"Atom pairs","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This section contains functions working with atom pairs.","category":"page"},{"location":"utils/#Sym4state.Utils.consider_pair_vec_in_radius","page":"Utilities","title":"Sym4state.Utils.consider_pair_vec_in_radius","text":"This function provides the pairs of atoms that are within a specified cutoff radius,  cutoff_radius, and include atoms from the center_idx_vec.\n\nconsider_pair_vec_in_radius(struc::Sym4state.Types.Struc, center_idx_vec::Vector{Int64}, cutoff_radius::Float64) -> Vector{Vector{Int64}}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.linear_idx_to_vec","page":"Utilities","title":"Sym4state.Utils.linear_idx_to_vec","text":"This function computes the index of the primitive cell that encompasses the atom at index idx.\n\nlinear_idx_to_vec(idx::Int64, supercell_size::Vector{Int64}, num_pri_sites::Int64) -> Vector{Int64}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_corresponding_pair_vec","page":"Utilities","title":"Sym4state.Utils.get_corresponding_pair_vec","text":"This function calculates the corresponding pair to the pair_vec after a specific operation.\n\nget_corresponding_pair_vec(corresponding_dict::Dict{Int64, Int64}, pair_vec::AbstractVector{Int64}) -> Vector{Int64}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.equal_pair","page":"Utilities","title":"Sym4state.Utils.equal_pair","text":"This function determines all the equivalent atom pairs for a Struc that encloses the atom at index center_idx_vec within a specified cutoff radius of cutoff_radius.  The symmetric operations are provided in the sym_op_vec.\n\nequal_pair(mag_struc::Sym4state.Types.Struc, center_idx_vec::Vector{Int64}, cutoff_radius::Float64, sym_op_vec::Vector{Sym4state.Types.SymOp}) -> Union{Tuple{Bool, Nothing, Nothing}, Tuple{Bool, DataStructures.DisjointSets{Vector{Int64}}, Dict{Vector{Int64}, Sym4state.Types.SymOp}}}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_fixed_pair_vec","page":"Utilities","title":"Sym4state.Utils.get_fixed_pair_vec","text":"This function converts the atom pairs,  which are identified by the indices of atoms in a supercell,  into pairs characterized by the indices of atoms in a primitive cell along with the index of the corresponding primitive cells.\n\nget_fixed_pair_vec(struc::Sym4state.Types.Struc, mag_num_vec::Vector{Int64}, supercell_size::Vector{Int64}, pair_vec::Vector{Int64}) -> Vector{Int64}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Inputs-and-outputs","page":"Utilities","title":"Inputs and outputs","text":"","category":"section"},{"location":"utils/#Sym4state.Utils.to_vasp_inputs","page":"Utilities","title":"Sym4state.Utils.to_vasp_inputs","text":"With the help of Pymatgen, this function reorganizes the map_vec containing Map objects and the paths of the template INCAR, POSCAR, POTCAR, and KPOINTS files into separate directories representing different magnetic configurations for subsequent DFT calculations.\n\nAdditional specific INCAR settings can be provided through the kwargs parameter.\n\nto_vasp_inputs(map_vec::Vector{Sym4state.Types.Map})\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_py_struc","page":"Utilities","title":"Sym4state.Utils.get_py_struc","text":"This function using Pymatgen to read the POSCAR file at filepath.\n\nget_py_struc(filepath::String) -> PythonCall.Py\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.grep_energy","page":"Utilities","title":"Sym4state.Utils.grep_energy","text":"This function retrieves the energy from the OSZICAR file located at oszicar_path.\n\ngrep_energy(oszicar_path) -> Float64\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_coeff_mat","page":"Utilities","title":"Sym4state.Utils.get_coeff_mat","text":"This function computes the interaction matrix utilizing the provided Map and the energies of various configurations stored in energy_vec.\n\nget_coeff_mat(map::Sym4state.Types.Map, energy_vec::Dict{Int8, Float64}) -> Matrix{Float64}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_one_interact_coeff_mat","page":"Utilities","title":"Sym4state.Utils.get_one_interact_coeff_mat","text":"This function calculates the interaction matrix using the provided Map and the directory cal_dir that contains the output files of DFT calculations.\n\nget_one_interact_coeff_mat(map::Sym4state.Types.Map, cal_dir::String) -> Matrix{Float64}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_all_interact_coeff_under_sym","page":"Utilities","title":"Sym4state.Utils.get_all_interact_coeff_under_sym","text":"This function computes all the equivalent interaction matrices within a group identified by groupid, employing coeffmat as the basis and considering the different relations stored in relation_vec.\n\nget_all_interact_coeff_under_sym(coeff_mat::Matrix{Float64}, group_idx::Int64, relation_vec::Vector{Sym4state.Types.CoeffMatRef}) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.get_pair_and_coeff","page":"Utilities","title":"Sym4state.Utils.get_pair_and_coeff","text":"This function calculates all the interaction matrices and their corresponding atom pairs using the DFT calculation outputs stored in cal_dir. The map_vec stores the relations among magnetic configurations used for calculating each interaction matrix, while the relation_vec stores the relations among different interaction matrices within a group.\n\nget_pair_and_coeff(map_vec::Vector{Sym4state.Types.Map}, relation_vec::Vector{Sym4state.Types.CoeffMatRef}, cal_dir::String) -> Tuple{Matrix{Int64}, Array{Float64, 3}}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Miscellaneous","page":"Utilities","title":"Miscellaneous","text":"","category":"section"},{"location":"utils/#Sym4state.Utils.set_rwigs","page":"Utilities","title":"Sym4state.Utils.set_rwigs","text":"This function retrieves the RWIGS values for the provided path poscar_path of the POSCAR file, as specified in the referenced paper.\n\nset_rwigs(poscar_path::String) -> Vector{Float64}\n\n\n\n\n\n\n","category":"function"},{"location":"utils/#Sym4state.Utils.check_unit_cell","page":"Utilities","title":"Sym4state.Utils.check_unit_cell","text":"This function checks whether the cutoff radius cutoff is big enough for the unit cell. This function is designed to bypass the errors when using CellListMap.jl in the reference of this file.\n\ncheck_unit_cell(unit_cell_matrix::AbstractMatrix{Float64}, cutoff::Float64) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"This page shows all the types defined in Sym4state.Types.","category":"page"},{"location":"types/#Module","page":"Types","title":"Module","text":"","category":"section"},{"location":"types/#Sym4state.Types","page":"Types","title":"Sym4state.Types","text":"This module defines structures containing crystal structures, symmetric operations as well as relation among different magnetic configurations.\n\nThis module exports:\n\nCoeffMatRef\nMap\nStruc\nSymOp\n\n\n\n\n\n","category":"module"},{"location":"types/#Types-and-methods","page":"Types","title":"Types and methods","text":"","category":"section"},{"location":"types/#Sym4state.Types.Atom","page":"Types","title":"Sym4state.Types.Atom","text":"The data structure designed to store an atom includes its atomic number, position, and spin.\n\nTwo Atoms can be deemed approximately equal using the isapprox function if they share the same atomic number, possess position vectors that are approximately equal, and have spin vectors that are approximately equal.\n\nstruct Atom{T<:AbstractFloat}\n\n\n\nnum::Int64\nAtomic number.\npos::StaticArraysCore.SVector{3, T} where T<:AbstractFloat\nPosition vector in fractional coordinates.\nspin::StaticArraysCore.SVector{3, T} where T<:AbstractFloat\nSpin direction vector in cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"types/#Sym4state.Types.Struc","page":"Types","title":"Sym4state.Types.Struc","text":"The data structure created for storing a material structure.\n\nstruct Struc\n\n\n\nuni_num::Int64\nUnique index number to identify the material.\nlattice_mat::StaticArraysCore.SMatrix\nThe lattice matrix [a b c].\natom_count::Int64\nNumber of atoms in this structure.\nnum_vec::StaticArraysCore.SVector\nAtomic numbers for different atoms.\npos_mat::StaticArraysCore.SMatrix\nFractional coordinates for different atoms.\nspin_mat::StaticArraysCore.SMatrix\nSpin directions for different atoms.\n\n\n\n\n\n","category":"type"},{"location":"types/#Sym4state.Types.Struc-Tuple{Int64}","page":"Types","title":"Sym4state.Types.Struc","text":"A convenient approach to construct a new Struc with essential parameters exclusively:\n\nStruc(uni_num::Int64, lattice_mat::AbstractArray{T, 2}, num_vec::AbstractVector{Int64}, pos_mat::AbstractArray{T, 2}, spin_mat::AbstractArray{T, 2}) -> Sym4state.Types.Struc\n\n\n\n\n\n\n","category":"method"},{"location":"types/#Sym4state.Types.SymOp","page":"Types","title":"Sym4state.Types.SymOp","text":"The data structure created for storing a symmetric operation.\n\nstruct SymOp{T<:AbstractFloat}\n\n\n\nrot_mat::StaticArraysCore.SMatrix{3, 3, T} where T<:AbstractFloat\nThe rotational matrix for atoms.\nspin_rot_mat::StaticArraysCore.SMatrix{3, 3, T} where T<:AbstractFloat\nThe rotational matrix for spins.\ntrans_vec::StaticArraysCore.SVector{3, T} where T<:AbstractFloat\nThe translation vector for atoms.\nproper::Bool\nThe indicator flag to denote the propriety of the rotation.\ntime_rev::Bool\nThe indicator flag to denote the presence of a time reversal operation.\n\n\n\n\n\n","category":"type"},{"location":"types/#Sym4state.Types.SymOp-Tuple{AbstractMatrix}","page":"Types","title":"Sym4state.Types.SymOp","text":"A convenient approach to construct a new SymOp with essential parameters exclusively:\n\nSymOp(rot_mat::AbstractArray{T, 2}, trans_vec::AbstractArray{T, 1}, time_rev::Bool, lattice_mat::AbstractArray{T, 2}, inv_lattice_mat::AbstractArray{T, 2}) -> Sym4state.Types.SymOp\n\n\n\n\nAs the spins are pseudovectors, their rotational matrix can be defined as:\n\nmathbfR^prime = T cdot mathbfR cdot mathbfR\n\nwhere mathbfR is the rotational matrix for atoms and T is the time reversal operation.\n\n\n\n\n\n","category":"method"},{"location":"types/#Sym4state.Types.Map","page":"Types","title":"Sym4state.Types.Map","text":"The data structure created for storing all the configurations needed to calculate an interaction matrix.\n\nstruct Map\n\n\n\nmap_mat::Matrix{Vector{Int8}}\nA matrix encompassing all the uni_num values of the configurations required to compute the elements of the interaction matrix.\nfallback_vec::Vector{Int8}\nA vector that stores the connections between the indices of the required real configurations within the set of all configurations.\nstruc_vec::Vector{Sym4state.Types.Struc}\nA vector that stores all the magnetic configurations.\ntype::Int64\nThe type of this interaction matrix. 1 for exchange interaction matrix while 2 for single-ion anisotropy matrix.\n\n\n\n\n\n","category":"type"},{"location":"types/#Sym4state.Types.Map-Tuple{DataStructures.IntDisjointSets, Vector{Sym4state.Types.Struc}}","page":"Types","title":"Sym4state.Types.Map","text":"A convenient approach to construct a new Map with essential parameters exclusively:\n\nMap(fallback_ds::DataStructures.IntDisjointSets, all_struc_vec::Vector{Sym4state.Types.Struc}) -> Sym4state.Types.Map\n\n\n\n\n\n\n","category":"method"},{"location":"types/#Sym4state.Types.CoeffMatRef","page":"Types","title":"Sym4state.Types.CoeffMatRef","text":"The data structure created for storing the equivalent relation between two atom pairs.\n\nstruct CoeffMatRef\n\n\n\ngroup_idx::Int64\nUnique index number to identify the group of those two atom pairs.\npair_vec::AbstractVector{Int64}\nA vector indicating two atom pairs.\nop::Sym4state.Types.SymOp\nThe operation linking those two atom pairs.\n\n\n\n\n\n","category":"type"}]
}
